[{"title":"2022-09-11 uCore","url":"/2022/09/11/2022-09-11-Ucore/","content":"Intel 80386运行模式实模式该状态下软甲可访问的物理内存空间不能超过1MB。将物理内存看成分段的区域，程序代码和数据位于不同的区域，操作系统和用户程序没有区别对待，每个指针都是指向实际的物理地址。\n保护模式确保应用程序无法对操作系统进行破坏\n支持内存分页机制，多任务和优先级机制\n不同的程序可以运行在不同的特权级上，有0-3四个特权级。操作系统运行在最高的特权级0上\nSMM模式虚拟8086模式分页分段机制分段机制启动、分页机制未启动：逻辑地址—&gt;段处理机制—&gt;线性地址&#x3D;物理地址\n分段机制和分页机制都启动：逻辑地址—&gt;段处理机制—&gt;线性地址—&gt;页处理机制—&gt;物理地址\ngcc各参数-fno-builtin 除非用_builtlin_前缀，否则不进行builtin函数的优化\n-Wall 生成所有警告信息\n-ggdb\t倾向于给GDB使用的debug信息\n-m32&#x2F;64\t只当编译为32&#x2F;64位应用程序\n-gstabs \t以stabs格式声称调试信息，不包括gdb调试信息\n-nostdinc\t使编译器不在系统默认的头文件目录里找头文件，一般和-l联合使用，明确限定头文件的位置\n-fno-stack-protector\t关闭栈保护\nucore.img文件生成过程从内核&#x2F;kern&#x2F;的init文件出发\ninit.c -&gt; stdio.c -&gt; readline.c -&gt; panic.c -&gt; kdebug.c -&gt; kmonitor.c -&gt; clock.c -&gt; console.c -&gt; picirq.c -&gt; intr.c -&gt; trap.c -&gt; vectors.c -&gt; trapentry.S -&gt; pmm.c -&gt; string.c -&gt; printfmt.c（到这里，来了一个ld /bin/kernel）\n生成了kernel\n接下来是编译&#x2F;boot&#x2F;和&#x2F;tools&#x2F;的文件来生成bootblock\nbootsam.S -&gt; bootmain.S -&gt; (&#x2F;tools&#x2F;)sign.c\n到最后，是将obj&#x2F;boot&#x2F;bootasm.o和obj&#x2F;boot&#x2F;bootmain.o文件编译为bootblock.o文件\n生成的out文件大小是488bytes，小于boot文件的512大小限制，故成功\n关于uCore生ucore.img的命令解释//生成一个有10000个块的文件，每个块默认512字节，用0填充dd if=/dev/zero of=bin/ucore.img count=10000//把bootblock中的文件写到第一个块dd if=bin/bootblock of=bin/ucore.img conv=notrunc//从第二个块开始写kernel的内容dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc\n\n\n\n一个被系统认为是符合规范的硬盘主引导扇区的特征从sign.c的代码来看，一个磁盘主引导扇区只有512字节，倒数第二个字节是0x55 倒数第一个字节是0xAA\n"},{"title":"20220822","url":"/2022/08/22/20220822/","content":"GCC基本内敛汇编语句和扩展内联汇编语句\n基本内联汇编\nasm(&quot;statements&quot;)\n\nasm和_asm_含义一样 如果有多行汇编，每行都要加上\\n\\t\n被操作的寄存器放在后面。\n\n在 AT&amp;T 汇编格式中，寄存器名要加上 ‘%’ 作为前缀 pushl %eax\n在 AT&amp;T 汇编格式中，用 ‘$’ 前缀表示一个立即操作数 pushl $1\n目标操作数在源操作数的右边 movl $1,%eax\n\n\n\n\n指令\n功能\n\n\n\nstd\n操作方向标志位DF使其为1\n\n\ncld\n操作方向标志位DF使其为0\n\n\nstosl\n将EAX中的值保存到ES:EDI指向的地址中。若设置了EFLAGS中的方向位置位(即在STOSL指令前使用STD指令)则EDI自减4，否则(使用CLD指令)EDI自增4；\n\n\nrep\n重复执行该指令后面的汇编代码，执行次数由寄存器ecx控制\n\n\n"},{"title":"2022-09-12 uCore","url":"/2022/09/12/2022-09-12-uCore/","content":"GDB常用命令查看内存x /nfu &lt;addr&gt;          //x 是 examine 的缩写\n\nn：要显示的内存单元的个数f：显示方式, 可取如下值\n\n\nx\n按十六进制格式显示变量\n\n\n\nd\n按十进制格式显示变量\n\n\nu\n按十进制格式显示无符号整型\n\n\no\n按八进制格式显示变量\n\n\nt\n按二进制格式显示变量\n\n\na\n按十六进制格式显示变量\n\n\ni\n指令地址格式\n\n\nc\n按字符格式显示变量\n\n\nf\n按浮点数格式显示变量\n\n\nu表示一个地址单元的长度\n\n\nb\n单字节\n\n\n\nh\n双字节\n\n\nw\n四字节\n\n\ng\n八字节\n\n\n分段机制逻辑地址、段描述符、段描述符表、段选择子（段寄存器，用于定位段描述符表中表项的索引）\n段描述符由三个参数进行定义：段基地址（Base Address）、段界限（Limit）、段属性（Attributes）\n段基地址规定线性地址空间中段的起始地址。长32位。\n80386保护模式下，基地址长度必须与寻址地址的长度相同，所以任何一个段都可以从32位线性地址空间中的任何一个字节开始。而在实模式下，边界必须被16整除。\n段界限规定段的大小。保护模式下，用20位标识，可以以字节为单位或4K字节为单位。\n段属性AT&amp;T汇编语言movw S, DS  –&gt; D穿字\nDS段寄存器Data Segment，存放数据段的数据地址\nES扩展段寄存器Extra Segment，当所给的几个段寄存器不够时用这个\nCS代码段寄存器Code Segment。存放代码段\nSS栈段寄存器，和sp一起用于栈。相当于堆栈段的首地址，sp相当于堆栈段的偏移地址\ntestb S2,S1S1 &amp; S2，测试字节，与关系\n.code16&#x2F;32生成16&#x2F;32位汇编代码\n.global xxx定义xxx作为程序入口\n"},{"title":"2022-09-13 uCore","url":"/2022/09/13/2022-09-13-uCore/","content":"CPU进入保护模式后，接下来是从硬盘上加载并运行OS。bootloader的访问硬盘是LBA模式的PIO(Program IO)方式，即所有的IO操作都是通过CPU访问硬盘的IO地址寄存器完成。\n一般主板有2个IDE通道，每个通道可以接2个IDE硬盘。访问第一个硬盘的山区通过IO地址寄存器0x1f0~0x1f7实现。每个通道的主从盘的选择是通过第6个IO偏移地址寄存器来设置\n\n\n\nIO地址\n功能\n\n\n\n0x1f0\n读数据，当0x1f7不为忙状态时，可以读。\n\n\n0x1f2\n要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区\n\n\n0x1f3\n如果是LBA模式，就是LBA参数的0-7位\n\n\n0x1f4\n如果是LBA模式，就是LBA参数的8-15位\n\n\n0x1f5\n如果是LBA模式，就是LBA参数的16-23位\n\n\n0x1f6\n第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘\n\n\n0x1f7\n状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据\n\n\n读扇区\ndefine SECTSIZE 512void readsect(void *dst, uint32_t secno)&#123;\twaitdisk();\t\t\t\t//等待磁盘准备好\t\toutb(0x1F2, 1);\t\t\t//设置只读取一个扇区/*\t第29~31位设置为1，28位=0表示访问“Disk 0”（硬盘1）\t0-27位是28位的偏移量*/\toutb(0x1F3, secno &amp; 0xFF);\toutb(0x1F4, (sceno &gt;&gt; 8) &amp; 0xFF);\toutb(0x1F4, (sceno &gt;&gt; 16) &amp; 0xFF);\toutb(0x1F4, (sceno &gt;&gt; 24) &amp; 0xF);\toutb(0x1F7, 0x20);\t\twaitdisk();\t//把磁盘扇区数据读到指定内存\tinsl(0x1F0, dst, SECTSIZE / 4);\t\t//读取到dst位置&#125;\n\nELF文件ELF(Executable and linking format)有三种类型\n用于执行的可执行文件(executable file)，用于提供程序的进程映像，加载的内存执行。\n用于连接的可重定位文件(relocatable file)，可与其他目标文件一起创建可执行文件和共享目标文件。\n共享目标文件(shared object file)，连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来来创建一个进程映像。\n实验六中断描述符表(Interrupt Descriptor Table)8字节描述符数组，把每个中断或异常编号和一个指向中断服务例程的描述符联系起来\n第2-3字节是段选择子，0-1和6-7字节拼成位移，两者联合便是中断处理程序的入口地址。\n第一项可以包含一个描述符\n中断（异常）号乘以8做为IDT的索引\nIDT可以存储于内存的任意位置，通过IDT寄存器（IDTR）内容来寻址IDT的起始地址\n指令LIDT(Load IDT Register)使用一个包含线性地址基址和界限的内存操作数来加载IDT\n用来设定IDT的起始地址\nSIDT(Store IDT Register)拷贝IDTR的基址和界限部分到一个内存地址\n可在任意特权级执行\n"},{"title":"20220823","url":"/2022/08/23/20220823/","content":"C语言位域结构体\n使用目的：存在某些信息的存储表示只需要几个bit位表示而无需使用一个完整的字节，以此节省空间和方便处理。\nstruct  bit_struct&#123;    int  bit1:3;    int  bit2:5;    int  bit3:7;&#125;data;\n\nbit_struct表示位域结构体，bit1、bit2、bit3表示对应的位域。整个位域结构体占用2个字节，bit1占3位，bit2占5位，bit1和bit2共用一个字节，bit3占7位，独占一个字节。\n如果位域长度为0表示这是个空域，下一个域应当从下一个字节单元开始存放。\n位域必须存储为同类型，位域长度不会超过所定义类型的长度。如果一个定义类型单元里所剩空间无法存放下一个域，则下一个域应该从下一单元开始存放。\n"},{"title":"NHWC转NCHW","url":"/2022/10/19/NHWC%E8%BD%ACNCHW/","content":""},{"title":"Rust特征关联类型还有点缺陷","url":"/2022/10/29/Rust%E7%89%B9%E5%BE%81%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%9C%89%E7%82%B9%E7%BC%BA%E9%99%B7/","content":"struct Container(i32, i32);trait Contains&#123;    type A;    type B;    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;    fn first(&amp;self) -&gt; Self::A;    fn last(&amp;self) -&gt; Self::B;&#125;impl Contains for Container&#123;    type A = i32;    type B = i32;    fn contains(&amp;self, number_1: &amp;Self::A, number_2: &amp;Self::B) -&gt; bool&#123;        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)    &#125;        fn first(&amp;self) -&gt; Self::A&#123;self.0&#125;    fn last(&amp;self) -&gt; Self::B&#123;self.1&#125;&#125;fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 &#123;    container.last() - container.first()&#125;fn main() &#123;    let number_1 = 3;    let number_2 = 10;    let container = Container(number_1, number_2);    println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;,        &amp;number_1, &amp;number_2,        container.contains(&amp;number_1, &amp;number_2));    println!(&quot;First number: &#123;&#125;&quot;, container.first());    println!(&quot;Last number: &#123;&#125;&quot;, container.last());        println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));&#125;\n\n如上所示的代码，会出现以下报错\nCompiling playground v0.0.1 (/playground)error[E0369]: cannot subtract `&lt;C as Contains&gt;::A` from `&lt;C as Contains&gt;::B`  --&gt; src/main.rs:31:22   |31 |     container.last() - container.first()   |     ---------------- ^ ----------------- &lt;C as Contains&gt;::A   |     |   |     &lt;C as Contains&gt;::B   |help: consider further restricting the associated type   |30 | fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 where &lt;C as Contains&gt;::B: Sub&lt;&lt;C as Contains&gt;::A&gt; &#123;   |                                                  +++++++++++++++++++++++++++++++++++++++++++++++++For more information about this error, try `rustc --explain E0369`.error: could not compile `playground` due to previous error\n\n意思指last和first返回的值时Self::A和Self::B，而不是已经在其中设置好的i32，故出现错误。所以，需要将last和first设置的返回值再次设为具体值i32。\n"},{"title":"qemu+gdb调试connection time out","url":"/2022/10/27/qemu-gdb%E8%B0%83%E8%AF%95connection-time-out/","content":"使用qemu和gdb调试时，当使用gdb监听1234端口时报错\nConnection timed out\n\n解决方法\n在qemu控制台输入\n(qemu) gdbserver tcp::1234\n\n"},{"title":"数字图像处理：二值图获取轮廓并覆盖至另一张图片上","url":"/2022/11/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E4%BA%8C%E5%80%BC%E5%9B%BE%E8%8E%B7%E5%8F%96%E8%BD%AE%E5%BB%93%E5%B9%B6%E8%A6%86%E7%9B%96%E8%87%B3%E5%8F%A6%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E4%B8%8A/","content":"输入的二值图背景应该是黑色，即像素为0，物体的颜色是白色，像素为255。该方法是按照白色来查找轮廓，否则会将整张图片的轮廓覆盖上去，尽管无伤大雅。\n# 寻找轮廓并合并def find_contours_mix(image, mask):\t//#image被覆盖的图片，mask灰度图    contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)    cv2.drawContours(image, contours, -1, (255, 0, 0), 3)    return image\n\ndrawContours的参数为-1指将所有的轮廓都覆盖\n","tags":["数字图像处理"]},{"title":"数字图像处理：填补分割图像内部空洞","url":"/2022/11/10/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E5%A1%AB%E8%A1%A5%E5%88%86%E5%89%B2%E5%9B%BE%E5%83%8F%E5%86%85%E9%83%A8%E7%A9%BA%E6%B4%9E/","content":"输入的二值图背景应该是黑色，即像素为0，物体的颜色是白色，像素为255。\n# 补全中间空隙def fix_blank(image):         im_floodfill = image.copy()    h, w = image.shape[:2]    mask = np.zeros((h+2, w+2), np.uint8)        cv2.floodFill(im_floodfill, mask, (0,0), 255);        im_floodfill_inv = cv2.bitwise_not(im_floodfill)        im_out = image | im_floodfill_inv    return im_out\n\n","tags":["数字图像处理"]},{"title":"rCore-20221027","url":"/2022/10/27/rCore-20221027/","content":"Rust#[no_mangle]将rust文件中的函数提供链接，使asm能够识别\n"},{"title":"c++ nodiscard","url":"/2022/10/20/c-nodiscard/","content":"nodiscard是C++17引入的一种标记符,其语法一般为[[nodiscard]]或[nodiscard(“string”)]，含义可以理解为“不应舍弃”。nodiscard一般用于标记函数的返回值或者某个类，当使用某个弃值表达式而不是cast to void 来调用相关函数时，编译器会发出相关warning。\n一个被nodiscard声明的函数被调用时，比如说：\n[[nodiscard]] int func()&#123;return 1;&#125;; // C++17[[nodiscard(&quot;nodiscard_func_1&quot;)]] int func_1()&#123;return 2;&#125;;  // C++20func(); // warningfunc_1(); // warning\n\n编译器警告如下：\nwarning C4834: 放弃具有 &quot;nodiscard&quot; 属性的函数的返回值warning C4858: 正在放弃返回值: nodiscard_func_1\n\n保存函数返回值，或者使用cast to void\n[[nodiscard]] int func()&#123;return 1;&#125;; // C++17int a = func(); // no warningstatic_cast&lt;void&gt;(func()); // no warning\n\n一个函数返回一个enum或class（这个enum或class被nodiscard声明了），该函数被调用时（或出现在其他函数的定义中）\nstruct [[nodiscard]] testStruct&#123;&#125;;class [[nodiscard]] testClass&#123;&#125;;enum class [[nodiscard]] testEnum&#123;test1, test2&#125;;testClass funcClass() &#123;return &#123;&#125;;&#125;testEnum funcEnum() &#123;return testEnum::test1;&#125;void func()&#123;\tfuncEnum(); // warning&#125;funcClass(); //warning\n\n\n值得注意的是，当函数返回class的引用或指针时，nodiscard无效\nclass [[nodiscard]] testClass&#123;&#125;;testClass&amp; funcClassRef() &#123;testClass A; return A;&#125;testClass* funcClassPtr() &#123;testClass A; return &amp;A;&#125;funcClassRef(); // no warningfuncClassPtr(); // no warning\n\n"},{"title":"MobileNet","url":"/2022/11/18/MobileNet/","content":"ReLU6在MobileNetV1中看到的，在3*3卷积后加入，用于限制最大输出为6。这是由于MobileNetV6适用于移动端时，移动端的精度往往较低，如使用float16类型，而当激活值非常大的时候，低精度不好表示$$ReLU(6)&#x3D;min(max(0,x),6)$$\nMobileNetV1主要使用了深度可分离卷积，使计算量大大减少\n引入了ReLU激活函数，更适配于移动端\nV2在V1中存在一个问题，在深度卷积后使用ReLU激活函数后会产生大量卷积核为空，尤其是在浅层的卷积层，而在深层情况要好一点。故将最后的ReLU激活函数换为线性激活函数。\n同时，由于深度卷积不能改变通道，所以深度卷积只能在低通道环境下工作，不太好？（这里打个问号，具体的原因我再查查）。故在深度卷积前先使用1*1*n的卷积核将通道扩大n倍，再进行处理。\n同时，还引入了shortcut结构，将一开始的数据移植到最后的全卷积结果中\n","tags":["DeepLearning"]},{"title":"A20地址线的用处","url":"/2022/09/12/A20%E5%9C%B0%E5%9D%80%E7%BA%BF%E7%9A%84%E7%94%A8%E5%A4%84/","content":"Intel处理器在一开始的8086&#x2F;8088中，只有20根地址总线，可访问的地址是2^20&#x3D;1M。而8086&#x2F;8088是16位地址模式，其地址范围是0-64K，所以为了能访问1M内存，采用分段模式：16位段基地址+16位便宜。绝对地址计算方法是16位基地址左移4位+16位偏移&#x3D;20位地址。\n最后能表示的最大内存位FFFF0h+FFFFh&#x3D;10FFEFh&#x3D;1M+64K-16Bytes。其实际表示的内容多于1M，故100000H~10FFEFh之间的内存不能访问，需要有多余的地址线才能访问。处理方法是对1M求模计算。这也是一开始的实模式的处理方式。\n随着技术迭代，地址总线增加，其能表示的内存位增多，以上需要进行求模处理的空间现在可以直接表示了。但Intel为了使后代兼容老版本的系统设计，对于1M以上的多余内存空间必须得保持和原来一样求模处理。但有时候又得考虑不求模。于是出现了保护模式。\n保护模式是在地址总线增加后才出现的，与实模式不同。实模式是对1M以上的地址进行求模处理，而保护模式则不进行求模处理。\n怎么开启保护模式呢？前提当然是有超过20根地址总线才可以开启，故A20地址线（从0~20，20就是第21根）需要开启，这样就可以直接访问了。\n所以保护模式是为了访问10FFEFh以上的内存而诞生的。即想要访问10FFEFH以上的内存，必须进入保护模式。\n汇编语言开启A20地址线\nA20地址位由键盘控制器芯片8042管理，8042有两个端口：0x60和0x64\n先发送0xd1命令到0x64端口，在发送0xdf命令到0x60端口\nseta20.1:   inb     $0x64,%al               # Wait for not busy   testb   $0x2,%al   jnz     seta20.1    movb    $0xd1,%al               # 0xd1 -&gt; port 0x64   outb    %al,$0x64 seta20.2:   inb     $0x64,%al               # Wait for not busy   testb   $0x2,%al   jnz     seta20.2    movb    $0xdf,%al               # 0xdf -&gt; port 0x60   outb    %al,$0x60\n","tags":["-操作系统OS"]},{"title":"2022-11-19随笔","url":"/2022/11/19/2022-11-19%E9%9A%8F%E7%AC%94/","content":"今天真的好无语啊\n之前接的安卓项目的人还在找我帮完善功能，真的不想理，都做七八个月了，工资就那么点（学生真好剥削）没办法，老师特地打电话找我了，我再帮最后一下\n昨天下午五点多睡了一觉，我就知道我晚上铁失眠了，于是当室友睡觉后头脑风暴了一下，发现了模型的一些不足，两点才睡的，不过睡眠质量很差，很浅。\n星期六早上九点，大学生的作息不都是在睡觉吗？竟然有nt学校安排上课（大四的实践课移到大三）老师还是企业的，公司我甚至没听过（可能我孤陋寡闻）\n讲的是Qt，和安卓有点像，这老师就是水时长，我都无语死了，一个简单的知识点要说n遍，写很详细的注释\n蹭着上课，我把模型改了一下，终于推出了V3。具体我就不能多说了，训练结果还没出来，也不知道改的好不好\n改模型的过程就像打怪升级一样，挺快乐的，哈哈哈\n","categories":["随笔"]}]